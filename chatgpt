def generate_elliptical_wing(naca_nums, num_points, z_values, chord_lengths, filenames, major_axis, minor_axis, num_interpolation_points=100):
    assert len(z_values) == len(chord_lengths), "The number of z_values must be equal to the number of chord_lengths"

    # determine the center and the two radii of the ellipse
    z_center = np.mean(z_values)
    r1 = [float(axis) / 2 for axis in major_axis]
    r1 = [float(axis) / 2 for axis in minor_axis]
    
    # create linear interpolation of z-values and chord lengths
    interp_z_values = np.linspace(z_values[0], z_values[-1], num_interpolation_points)
    interp_chord_lengths = np.interp(interp_z_values, z_values, chord_lengths)

    # adjust interpolated chord lengths according to the ellipse equation
    ellipse_value = ((interp_z_values - z_center) / r1) ** 2
    adjusted_chord_lengths = r2 * np.sqrt(1 - np.clip(ellipse_value, 0, 1))
    
    # normalize adjusted chord lengths to match the user-inputted range
    min_chord_length, max_chord_length = min(chord_lengths), max(chord_lengths)
    min_adj, max_adj = min(adjusted_chord_lengths), max(adjusted_chord_lengths)
    adjusted_chord_lengths = ((adjusted_chord_lengths - min_adj) / (max_adj - min_adj)) * (max_chord_length - min_chord_length) + min_chord_length

    # generate airfoils with adjusted chord lengths
    airfoils = airfoil_wrapper(naca_nums, num_points, interp_z_values.tolist(), adjusted_chord_lengths.tolist(), filenames)

    return airfoils, interp_z_values, adjusted_chord_lengths

def airfoil_wrapper(naca_nums, num_points, z_values, chord_lengths, naca_airfoil_generation, filenames):    
    airfoils = []

    def airfoil_extract(chord_length, filename):
        steps = []
        with open(filename, 'r') as file:
            lines = file.readlines()

        # skip the first line as it's a header
        for line in lines[1:]:
            x, y = map(float, line.split())
            steps.append(fc.Point(x=x*chord_length, y=y*chord_length, z=0))
        return steps
                    
    if naca_airfoil_generation:
        for z_value, chord_length, filename in zip(z_values, chord_lengths, filenames):
            airfoil = airfoil_extract(chord_length, filename)
            airfoil = [fc.Point(x=point.x, y=point.y, z=z_value) for point in airfoil]
            airfoils.append(airfoil)
    else:
        for naca_num, z_value, chord_length in zip(naca_nums, z_values, chord_lengths):
            airfoil = naca_airfoil(naca_num, num_points, chord_length)
            airfoil = [fc.Point(x=point.x, y=point.y, z=z_value) for point in airfoil]
            airfoils.append(airfoil)

    return airfoils

def generate_shapes(shape_function, naca_nums, z_values, chord_lengths):
    return [shape_function(naca_num, z_value, chord_length) for naca_num, z_value, chord_length in zip(naca_nums, z_values, chord_lengths)]

def lerp_points(p1, p2, t):
    x = (1 - t) * p1.x + t * p2.x
    y = (1 - t) * p1.y + t * p2.y
    z = (1 - t) * p1.z + t * p2.z
    return fc.Point(x=x, y=y, z=z)

def create_single_layer(args):
    i, shape1, shape2, z_values, layer_height = args
    num_layers = int((z_values[i+1] - z_values[i]) / layer_height)
    layers = []
    if num_layers > 0:
        for j in range(num_layers):
            t = j / num_layers
            layer = [lerp_points(p1, p2, t) for p1, p2 in zip(shape1, shape2)]
            layers.append(layer)
    return layers

def loft_shapes(airfoils, z_values, layer_height, infill_density, generate_infill, generate_circle, circle_centers, circle_radiuses, circle_num_points, infill_type):    
    # (BETA) Multithreading.
    with concurrent.futures.ThreadPoolExecutor() as executor:
        layers = list(executor.map(create_single_layer, [(i, shape1, shape2, z_values, layer_height) for i, (shape1, shape2) in enumerate(zip(airfoils[:-1], airfoils[1:]))]))    

    steps = []

    # Flatten the layers list
    layers = [point for sublist in layers for point in sublist]

    # Pre-calculate circle layers if possible
    circle_layers = []
    if generate_circle:
        circle_layers = generate_circle_layers(circle_centers, circle_radiuses, circle_num_points, layer_height)

    for layer in layers:
        # Combine list extensions
        if len(steps) == 0:
            steps.extend(layer)
        else:
            steps.append(layer[-1])
            steps.append(layer[0])
            steps.extend(layer[1:])

        if generate_infill:
            min_x = min(point.x for point in layer)
            max_x = max(point.x for point in layer)
            min_y = min(point.y for point in layer)
            max_y = max(point.y for point in layer)
            if infill_type == triangle_wave_infill:
                steps = triangle_wave_infill(steps, layer[0].z, max_x, infill_density)
            else:
                if infill_type == modified_triangle_wave_infill:
                    steps = modified_triangle_wave_infill(steps, layer[0].z, min_x, max_x, infill_density)
                else:
                    steps = infill_type(steps, layer[0].z, min_x, max_x, min_y, max_y, infill_density)

        # Add pre-calculated circle layers to the steps
        for layer in circle_layers:
            steps.extend(layer)

    return steps


# Airfoil
naca_nums = ['2412', '2412']  # List of NACA airfoil numbers, if generating using naca method
num_points = 128 # The resolution / accuracy of your airfoil

# File extraction (WARNING: BETA, May not work correctly.)
file_extraction = False # If you want to extract data from a file. False If you want to use the 4-Digit NACA airfoil method for generating airfoils instead.
filenames = ['data.dat', 'data.dat'] # If you want to extract the coordinates from a file.

# Wing parameters
z_values = [0, 300]  # List of z-values for the airfoils
chord_lengths = [150, 100]  # Chord lengths of the airfoils

# Elliptical Wing Generation
generate_elliptical = True


if generate_elliptical:
    airfoils, z_values, chord_lengths = generate_elliptical_wing(naca_nums, num_points, z_values, chord_lengths, file_extraction, filenames, major_axis, minor_axis)
else:
    airfoils = airfoil_wrapper(naca_nums, num_points, z_values, chord_lengths, file_extraction, filenames)
            
steps = loft_shapes(airfoils, z_values, layer_height, infill_density, generate_infill, generate_circle, circle_centers, circle_radiuses, circle_num_points, infill_type)

airfoil_wrapper(naca_nums, num_points, z_values, chord_lengths, naca_airfoil_generation, filenames)

#Can you help me with this? I have a system that creates a loft between airfoils. 
#Can you help me create a bit of curve between the lofts? 
#You need to edit the z_values and chord_lengths lists to create a ellipse on the trailing edge of the wing. 
#The leading edge is set at x0. 
#The trailing edge is at x=chord_length 
#NOTE: Keep in mind that the variable is chord_length not chord_lengths. 
#The chord_length should be used as a current chord length. The output should be a list of airfoils at different z heights. 
#You probably need to add more z heights than the user inputs to create the ellipse / curve. The curve generation should be highly customizable as well. 
#Use the z_heights and chord_lengths to create, a for now small script. The script should calculate the points to create a ellipse to the trailing edge. 
#And edit the list of chord_lengths and z_values. Then, pass the values to a function called airfoil_wrapper which generates the airfoils. 
#Then you need to generate more layers in between and create the loft. My idea is probably flawed so use you imagination. 
#Here's some parameters for the generation of the loft. The naca_nums list should be the same length as the z_values and the chord_lengths lists. 
#The arguments that are passed to generate_elliptical_wing (which is the name of the function you should create) are not set in stone so you can change them.

# Airfoil
naca_nums = ['2412', '2412']  # List of NACA airfoil numbers, if generating using naca method
num_points = 128 # The resolution / accuracy of your airfoil

# File extraction (WARNING: BETA, May not work correctly.)
file_extraction = False # If you want to extract data from a file. False If you want to use the 4-Digit NACA airfoil method for generating airfoils instead.
filenames = ['data.dat', 'data.dat'] # If you want to extract the coordinates from a file.

# Wing parameters
z_values = [0, 300]  # List of z-values for the airfoils
chord_lengths = [150, 100]  # Chord lengths of the airfoils

# Elliptical Wing Generation
generate_elliptical = True


if generate_elliptical:
    airfoils, z_values, chord_lengths = generate_elliptical_wing(naca_nums, num_points, z_values, chord_lengths, file_extraction, filenames, major_axis, minor_axis)
else:
    airfoils = airfoil_wrapper(naca_nums, num_points, z_values, chord_lengths, file_extraction, filenames)
            
steps = loft_shapes(airfoils, z_values, layer_height, infill_density, generate_infill, generate_circle, circle_centers, circle_radiuses, circle_num_points, infill_type)
